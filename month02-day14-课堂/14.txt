前情回顾

1. 进程对象属性
   pid   daemon

2. getpid() getppid()  exit()

   孤儿进程
   僵尸进程    join()   signal()

3. 自定义进程类

   继承Process --》重写init,super()加载父类init--》重写run

   class Process:
       def __init__(target=None):
           self._target = target

       def run(self):
           self._target()

       def start(self):
           self.run()

4. 进程池 （大量的小任务需要多进程完成）

   Pool()
   apply_async()
   close()
   join()

5. 消息队列
   Queue()
   p.get()
   p.put()

群聊聊天室

需求分析 ： 要点 -》构建出软件的基本使用方法
    【1】 有人进入聊天室需要输入姓名，姓名不能重复
    【2】 有人进入聊天室时，其他人会收到通知：xxx 进入了聊天室
    【3】 一个人发消息，其他人会收到：xxx ： xxxxxxxxxxx
    【4】 有人退出聊天室，则其他人也会收到通知:xxx退出了聊天室

技术分析 ： 使用的技术

    * C / S 模型

    * 服务端存储用户信息 ： 姓名 和 address
      [(name,address),....]

      {name:address}

      class Person:
        def __init__(self,name,address):
            self.name = name
            self.address = address

    * 网络通信 ： udp

    * 消息传输机制:  客户端 ---》 服务端 --》转发给其他客户端

    * 收发消息互不影响 ： 多进程，一个进程负责收消息，一个负责发消息

功能模块分析

    * 整体框架设计
    * 进入聊天室
    * 聊天
    * 退出聊天室

    封装 ： 函数


通信协议设计 ： 数据传输中双方做一些数据格式和含义的约定

                请求类型    数据参量
  进入聊天室      L           name
　　
　　聊天　　　　　　C           name 消息内容

  退出           E            name

模块逻辑设计

    * 整体框架设计

      服务端： 1.创建udp网络套接字
              2.循环接收来自客户端的请求
              3.根据请求调用不同的函数去解决

      客户端： 1. 建立网络套接字

    * 进入聊天室

       客户端 ： 1.输入用户名
                2. 发送用户名
                3. 等待进入聊天室 --》 Y 进入聊天室
                                    N  重新回到第一步

       服务端:  1. 接收用户名
               2. 判断是否已经存在
               3. 存在 --》 告知客户端 无法进入
                  不存在 --》 告知客户端进入聊天室
               4. 客户端进入聊天室则  存储用户信息，告知其他用户

    * 聊天
         客户端 ：　创建子进程
         　　　　　　父进程循环发送消息
         　　　　　　子进程循环接收消息
        　
       　 服务端　：　接收消息
       　　　　　　　　转发给其他人
         　

    * 退出聊天室

优化完善
* 显示效果
* 客户端强行退出


练习1： 模拟售票系统
现有500 张票 记为 T1--T500   放在一个列表
有10个窗口一起买票  记为 w1 -- w10 ,每张票卖出需要0.1秒
创建10个线程 模拟10个窗口，票的售出顺序必须是1--500
每张票卖出时 打印  w2----T203

编程创建10个 线程模拟这个过程

作业 ： 1. 线程方法，熟练使用
       2. 聊天室  写一遍












